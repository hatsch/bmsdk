/* -LICENSE-START-
** Copyright (c) 2022 Blackmagic Design
**  
** Permission is hereby granted, free of charge, to any person or organization 
** obtaining a copy of the software and accompanying documentation (the 
** "Software") to use, reproduce, display, distribute, sub-license, execute, 
** and transmit the Software, and to prepare derivative works of the Software, 
** and to permit third-parties to whom the Software is furnished to do so, in 
** accordance with:
** 
** (1) if the Software is obtained from Blackmagic Design, the End User License 
** Agreement for the Software Development Kit (“EULA”) available at 
** https://www.blackmagicdesign.com/EULA/DeckLinkSDK; or
** 
** (2) if the Software is obtained from any third party, such licensing terms 
** as notified by that third party,
** 
** and all subject to the following:
** 
** (3) the copyright notices in the Software and this entire statement, 
** including the above license grant, this restriction and the following 
** disclaimer, must be included in all copies of the Software, in whole or in 
** part, and all derivative works of the Software, unless such copies or 
** derivative works are solely in the form of machine-executable object code 
** generated by a source language processor.
** 
** (4) THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS 
** OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
** FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT 
** SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE 
** FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE, 
** ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
** DEALINGS IN THE SOFTWARE.
** 
** A copy of the Software is available free of charge at 
** https://www.blackmagicdesign.com/desktopvideo_sdk under the EULA.
** 
** -LICENSE-END-
*/

#import "platform.h"
#import "DeckLinkMetalMultiViewWidget.h"
#import "DeckLinkPreviewWidget.h"
#import <MetalKit/MetalKit.h>

#include <mutex>
#include <vector>

#include <QGridLayout>
#include <QScreen>
#include <QWindow>

constexpr MTLPixelFormat    kMtlOverlayPixelFormat  = MTLPixelFormatBGRA8Unorm;
constexpr QImage::Format    kQtOverlayImageFormat   = QImage::Format_ARGB32;
constexpr int               kQtOverlayBytesPerPixel = 4;

static NSString* const kMetalLibrarySource = @""
"#include <metal_stdlib>\n"
"using namespace metal;\n"
"\n"
"typedef struct\n"
"{\n"
"	float4 renderedCoordinate [[position]];\n"
"	float2 textureCoordinate;\n"
"} TextureMappingVertex;\n"
"\n"
"vertex TextureMappingVertex vertexTextureMap(unsigned int vertex_id [[ vertex_id ]], \n"
"											 constant float4 *vertices [[buffer(0)]])\n"
"{\n"
"	const float4x2 textureCoordinates = float4x2(float2( 0.0, 1.0 ),\n"
"												 float2( 1.0, 1.0 ),\n"
"												 float2( 0.0, 0.0 ),\n"
"												 float2( 1.0, 0.0 ));\n"
""
"	TextureMappingVertex outVertex;\n"
"	outVertex.renderedCoordinate = vertices[vertex_id];\n"
"	outVertex.textureCoordinate = textureCoordinates[vertex_id % 4];\n"
"\n"
"	return outVertex;\n"
"}\n"
"\n"
"fragment half4 fragmentShader(TextureMappingVertex mappingVertex [[ stage_in ]],\n"
"							  texture2d<float, access::sample> texture [[ texture(0) ]])\n"
"{\n"
"	constexpr sampler s(address::clamp_to_edge, filter::linear);\n"
"	return half4(texture.sample(s, mappingVertex.textureCoordinate));\n"
"}";


@class DeckLinkMetalMultiView;

struct DeckLinkMetalMultiViewDelegate
{
	DeckLinkMetalMultiView* view;
};

struct DeckLinkMetalView
{
	com_ptr<IDeckLinkMetalScreenPreviewHelper>		previewHelper;
	id<MTLTexture>									pendingOverlayTexture;
	NSRect											previewRect;
};

@interface DeckLinkMetalMultiView : MTKView
@end

@implementation DeckLinkMetalMultiView
{
	std::vector<std::unique_ptr<DeckLinkMetalView>>		m_metalViews;
	std::mutex											m_overlayMutex;
	std::mutex											m_viewportMutex;

	id<MTLCommandQueue>									m_commandQueue;
	id<MTLRenderPipelineState>							m_pipelineState;

	NSSize												m_scaleFactor;
}

// MTKView
- (id)initWithFrame:(CGRect)frameRect device:(id<MTLDevice>)device viewCount:(uint)viewCount
{
	for (uint i = 0; i < viewCount; ++i)
	{
		com_ptr<IDeckLinkMetalScreenPreviewHelper> previewHelper = com_ptr<IDeckLinkMetalScreenPreviewHelper>(CreateMetalScreenPreviewHelper());
		if (!previewHelper)
			return nil;

		auto view = std::unique_ptr<DeckLinkMetalView>(new DeckLinkMetalView);
		view->previewHelper = std::move(previewHelper);
		view->pendingOverlayTexture = nil;
		view->previewRect = NSMakeRect(0.0, 0.0, 1.0, 1.0);

		m_metalViews.push_back(std::move(view));
	}

	m_scaleFactor = NSMakeSize(1.0, 1.0);

	// Init MTLView itself, configure redraw to occur when underlying widget calls setNeedDisplay
	[super initWithFrame:frameRect device:device];
	self.paused = YES;
	self.enableSetNeedsDisplay = YES;

	m_commandQueue = [device newCommandQueue];

	NSError* libraryError;
	id<MTLLibrary> library;
	id<MTLFunction> vertexFunction;
	id<MTLFunction> displayFunction;
	MTLRenderPipelineDescriptor* pipelineDescriptor;

	@try
	{
		library = [device newLibraryWithSource:kMetalLibrarySource options:nil error:&libraryError];
		vertexFunction = [library newFunctionWithName:@"vertexTextureMap"];
		displayFunction = [library newFunctionWithName:@"fragmentShader"];

		pipelineDescriptor = [[MTLRenderPipelineDescriptor alloc] init];
		pipelineDescriptor.vertexFunction = vertexFunction;
		pipelineDescriptor.fragmentFunction = displayFunction;
		pipelineDescriptor.colorAttachments[0].pixelFormat = kMtlOverlayPixelFormat;
		pipelineDescriptor.colorAttachments[0].blendingEnabled = YES;
		pipelineDescriptor.colorAttachments[0].rgbBlendOperation = MTLBlendOperationAdd;
		pipelineDescriptor.colorAttachments[0].alphaBlendOperation = MTLBlendOperationAdd;
		pipelineDescriptor.colorAttachments[0].sourceRGBBlendFactor = MTLBlendFactorSourceAlpha;
		pipelineDescriptor.colorAttachments[0].sourceAlphaBlendFactor = MTLBlendFactorSourceAlpha;
		pipelineDescriptor.colorAttachments[0].destinationRGBBlendFactor = MTLBlendFactorOneMinusSourceAlpha;
		pipelineDescriptor.colorAttachments[0].destinationAlphaBlendFactor = MTLBlendFactorOneMinusSourceAlpha;

		m_pipelineState = [device newRenderPipelineStateWithDescriptor:pipelineDescriptor error:&libraryError];
	}
	@catch (NSException*)
	{
		[m_pipelineState release];
		m_pipelineState = nil;
	}
	@finally
	{
		[library release];
		[vertexFunction release];
		[displayFunction release];
		[pipelineDescriptor release];
	}

	for (uint i = 0; i < m_metalViews.size(); ++i)
		m_metalViews[i]->previewHelper->Initialize((void*)device);

	return self;
}

- (void)dealloc
{
	for (uint i = 1; i < m_metalViews.size(); ++i)
		[self releaseTexture:m_metalViews[i]->pendingOverlayTexture];

	[m_commandQueue release];
	[m_pipelineState release];
	[super dealloc];
}

- (void)updateFrame:(IDeckLinkVideoFrame *)frame forView:(uint)view
{
	if (view > m_metalViews.size())
		return;

	if (m_metalViews[view]->previewHelper)
		m_metalViews[view]->previewHelper->SetFrame(frame);
}

- (void)updateOverlay:(id<MTLTexture>)overlayTexture forView:(uint)view
{
	if (view > m_metalViews.size())
		return;

	std::lock_guard<std::mutex> lock(m_overlayMutex);
	[self releaseTexture:m_metalViews[view]->pendingOverlayTexture];
	m_metalViews[view]->pendingOverlayTexture = overlayTexture;
}

- (void)setViewportSize:(NSRect)rect forView:(uint)view
{
	if (view > m_metalViews.size())
		return;

	std::lock_guard<std::mutex> lock(m_viewportMutex);
	m_metalViews[view]->previewRect = rect;
}

- (void)clearTextureForView:(uint)view
{
	std::lock_guard<std::mutex> lock(m_overlayMutex);
	[self releaseTexture:m_metalViews[view]->pendingOverlayTexture];
	m_metalViews[view]->pendingOverlayTexture = nil;
}

- (void)releaseTexture:(id<MTLTexture>)texture
{
	if (texture)
	{
		[[texture buffer] release];
		[texture release];
	}
}

- (void)resizeView:(NSRect)rect
{
	[self setFrameOrigin:rect.origin];
	[self setFrameSize:rect.size];

	CGSize drawableSize = [self drawableSize];
	m_scaleFactor = NSMakeSize(drawableSize.width / rect.size.width, drawableSize.height / rect.size.height);
}

// NSView
- (void)drawRect:(NSRect)dirtyRect
{
	id<CAMetalDrawable> drawable = [self currentDrawable];
	if (!drawable)
		return;

	std::vector<MTLViewport> viewports;
	id<MTLCommandBuffer> commandBuffer = [m_commandQueue commandBuffer];
	MTLRenderPassDescriptor *renderPassDescriptor = [MTLRenderPassDescriptor renderPassDescriptor];

	for (uint i = 0; i < m_metalViews.size(); ++i)
	{
		MTLViewport viewport;
		{
			std::lock_guard<std::mutex> lock(m_viewportMutex);
			viewport.originX    = m_metalViews[i]->previewRect.origin.x * m_scaleFactor.width;
			viewport.originY    = m_metalViews[i]->previewRect.origin.y * m_scaleFactor.height;
			viewport.width      = m_metalViews[i]->previewRect.size.width * m_scaleFactor.width;
			viewport.height     = m_metalViews[i]->previewRect.size.height * m_scaleFactor.height;
			viewport.znear      = 0.0;
			viewport.zfar       = 1.0;
		}

		if (@available(macOS 10.15, *))
		{
			renderPassDescriptor.renderTargetWidth = drawable.texture.width;
			renderPassDescriptor.renderTargetHeight = drawable.texture.height;
		}
		renderPassDescriptor.colorAttachments[0].texture = drawable.texture;
		renderPassDescriptor.colorAttachments[0].loadAction = i == 0 ? MTLLoadActionClear : MTLLoadActionLoad;
		renderPassDescriptor.colorAttachments[0].clearColor = MTLClearColorMake(0.0, 0.0, 0.0, 1.0);
		renderPassDescriptor.colorAttachments[0].storeAction = MTLStoreActionStore;

		m_metalViews[i]->previewHelper->Draw((void*)commandBuffer, (void*)renderPassDescriptor, (void*)&viewport);

		viewports.push_back(viewport);
	}

	// Print overlay
	renderPassDescriptor.colorAttachments[0].loadAction = MTLLoadActionLoad;
	id<MTLRenderCommandEncoder> commandEncoder = [commandBuffer renderCommandEncoderWithDescriptor:renderPassDescriptor];

	for (uint i = 0; i < m_metalViews.size(); ++i)
	{
		id<MTLTexture> inFlightTexture;
		{
			std::lock_guard<std::mutex> lock(m_overlayMutex);
			inFlightTexture = m_metalViews[i]->pendingOverlayTexture;
		}

		if (inFlightTexture)
		{
			// Construct vertices to render overlay over the view.
			simd_float4 overlayVertices[4] =
			{
				{ -1.0, -1.0,  0.0,  1.0 },
				{  1.0, -1.0,  0.0,  1.0 },
				{ -1.0,  1.0,  0.0,  1.0 },
				{  1.0,  1.0,  0.0,  1.0 }
			};

			[commandEncoder setRenderPipelineState:m_pipelineState];
			[commandEncoder setViewport:viewports[i]];
			[commandEncoder setFragmentTexture:inFlightTexture atIndex:0];
			[commandEncoder setVertexBytes:overlayVertices length:sizeof(overlayVertices) atIndex:0];
			[commandEncoder drawPrimitives:MTLPrimitiveTypeTriangleStrip vertexStart:0 vertexCount:4];
		}
	}
	[commandEncoder endEncoding];

	[commandBuffer presentDrawable:drawable];
	[commandBuffer commit];
}

@end

/// DeckLinkMetalMultiViewWidget

DeckLinkMetalMultiViewWidget::DeckLinkMetalMultiViewWidget(QWidget *parent, uint viewCount) :
	QWidget(parent)
{
	m_delegate = std::unique_ptr<DeckLinkMetalMultiViewDelegate>(new DeckLinkMetalMultiViewDelegate);
	id<MTLDevice> device = MTLCreateSystemDefaultDevice();

	m_delegate->view = [[DeckLinkMetalMultiView alloc] initWithFrame:NSMakeRect(0.0, 0.0, 1.0, 1.0) device:device viewCount:viewCount];
	m_delegate->view.clearColor = MTLClearColorMake(0.0, 0.0, 0.0, 1.0);
	m_delegate->view.autoresizingMask = NSViewWidthSizable | NSViewHeightSizable;
	m_delegate->view.wantsLayer = YES;

	NSView* widgetView = reinterpret_cast<NSView*>(this->winId());
	[widgetView addSubview:m_delegate->view];
}

DeckLinkMetalMultiViewWidget::~DeckLinkMetalMultiViewWidget()
{
	[m_delegate->view removeFromSuperview];
	[m_delegate->view release];
}

/// DeckLinkMetalMultiViewWidget slots

void DeckLinkMetalMultiViewWidget::setFrame(com_ptr<IDeckLinkVideoFrame> frame, uint view)
{
	[m_delegate->view updateFrame:frame.get() forView:(uint)view];
}

void DeckLinkMetalMultiViewWidget::updateViewGeometry(QRect viewRect, uint view)
{
	// Clear out textures of old geometry
	[m_delegate->view clearTextureForView:(uint)view];

	[m_delegate->view setViewportSize:NSMakeRect(viewRect.left(),
													 viewRect.top(),
													 viewRect.width(),
													 viewRect.height())
								  forView:(uint)view];

	// Notify to update display with new geometry
	[m_delegate->view setNeedsDisplay:YES];
}

void DeckLinkMetalMultiViewWidget::paintOverlay(uint view)
{
	QGridLayout* layout = qobject_cast<QGridLayout*>(this->layout());
	if (!layout || (int)view >= layout->count())
		return;

	// Paint the overlay for view
	DeckLinkPreviewWidget* previewWidget = qobject_cast<DeckLinkPreviewWidget*>(layout->itemAt(view)->widget());

	int widgetWidth = previewWidget->width();
	int widgetHeight = previewWidget->height();

	// Buffer-backed textures in Metal should have rows aligned to 256-bytes
	int bytesPerRow = ((widgetWidth * kQtOverlayBytesPerPixel) + 0xff) & ~0xff;
	int bufferLength = bytesPerRow * widgetHeight;
	id<MTLBuffer> overlayBuffer = [[m_delegate->view device] newBufferWithLength:(NSUInteger)bufferLength options:MTLResourceStorageModeManaged];

	MTLTextureDescriptor *desc = [[MTLTextureDescriptor alloc] init];
	desc.width = widgetWidth;
	desc.height = widgetHeight;
	desc.usage = MTLTextureUsageShaderRead;
	desc.pixelFormat = kMtlOverlayPixelFormat;
	desc.storageMode = MTLStorageModeManaged;

	uchar* contents = (uchar*)[overlayBuffer contents];
	id<MTLTexture> texture = [overlayBuffer newTextureWithDescriptor:desc offset:0 bytesPerRow:bytesPerRow];
	[desc release];

	QImage overlayImage(contents, widgetWidth, widgetHeight, bytesPerRow, kQtOverlayImageFormat);
	previewWidget->overlay()->paint(&overlayImage);
	[overlayBuffer didModifyRange:NSMakeRange(0, [overlayBuffer length])];

	[m_delegate->view updateOverlay:texture forView:view];

	// Notify to update display with new frame and overlay
	[m_delegate->view setNeedsDisplay:YES];
}

/// QWidget events

void DeckLinkMetalMultiViewWidget::showEvent(QShowEvent* event)
{
	NSView* widgetView = reinterpret_cast<NSView*>(this->winId());
	[m_delegate->view resizeView:[widgetView bounds]];
	[m_delegate->view setNeedsDisplay:YES];

	// Keep track of changes to screen which may impact DPI scaling
	connect(this->windowHandle(), &QWindow::screenChanged, this, &DeckLinkMetalMultiViewWidget::screenChanged);

	QWidget::showEvent(event);
}

void DeckLinkMetalMultiViewWidget::screenChanged(QScreen* screen)
{
	Q_UNUSED(screen)

	NSView* widgetView = reinterpret_cast<NSView*>(this->winId());
	[m_delegate->view resizeView:[widgetView bounds]];
	[m_delegate->view setNeedsDisplay:YES];

}

